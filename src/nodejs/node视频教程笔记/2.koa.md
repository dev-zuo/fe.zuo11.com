# Koa

## node基础复习
### node api 三种调用方式
```js
// 1.一般 node调用api使用的是callback方式
fun('./index1.js', (err, data) => {
  console.log(err ? 'read err' : data)
})
// 模拟实现
function fun(arg, callback) {
  try {
    aaa() // 执行一些内部操作
    callback(null, 'result') // 如果执行成功，err设置为null, 结果通过第二参数返回
  } catch(e) {
    callback(e)
  }
}

// 通过 promisify 改造后的fun函数
const { promisify } = require('util')
const promisefun = promisify(fun)

// 2.promise方式调用
promisefun('./index1.js').then((data) => {
  console.log(data)
}, (err) => {
  // 如果后面有.catch 这里的优先级会高一点
  console.log(err)
})
// 或者
promisefun('./index1.js').then((data) => {
  console.log(data)
}).catch(err => {
  console.log('read err')
})

// 3.通过async/await 调用promise函数
// await 需要用 async 函数包裹
setTimeout(async () => {
  try {
    let data = await promisefun('./index1.js')
    console.log(data)
  } catch(e) {
    console.log('read err')
  }
}, 0)

```

### util模块内置 promisify 实现
promisify 可以把老的callback方式，转换为promise函数，怎么实现的呢？
```js
// 普通callback方式
function fun(arg, callback) {
  try {
    aaa() // 执行一些内部操作
    callback(null, 'result', 'result2') // 如果执行成功，err设置为null, 结果通过第二参数返回
  } catch(e) {
    callback(e)
  }
}

// promisify模拟实现
function promisify(fun) {
  // 生成的函数，会接收一个参数arg，数据和错误，需要我们在promise内部用reject或resolve传出结果
  return function(...args) {
    // 将传入的参数保存到args数组
    return new Promise((resolve, reject) => {
      // 将callback函数push到参数数组里，再间接调用fun
      args.push((err, result) => {
        // 如果fun函数执行成功会执行该函数并传入 (null, result)
        // 如果fun函数执行错误会执行该函数并传入 (err)
        // resolve() 只能接受并处理一个参数，多余的参数会被忽略掉。 spec上就是这样规定。
        // 如果回调函数，传出了多个参数，可以将该函数result换为 ...result
        // 然后resove时判断下，如果 result数组长度为0 直接resolve(result[0])，否则resove(result数组)，接收参数时需要注意
        err ? reject(err) : resolve(result)
      })
      fun.apply(null, args)
    })
  }
}

// 测试
let promisefun = promisify(fun)
promisefun('./index1.js').then((data) => {
  console.log(data)
}, (err) => {
  // 如果后面有.catch 这里的优先级会高一点
  console.log('read err')
})
```

## Koa
Koa是由 Express 原班人马打造的致力于成为一个更小、更富有表现力、更健壮的 web 开发框架。

官方解释：Expressive middleware for node.js using ES2017 async functions 

github: [koajs/koa](https://github.com/koajs/koa)

### 特点
中间件机制、请求、响应处理
- 轻量、无捆绑
- 中间件构架
- 优雅的API设计
- 增强的错误处理
### Koa1与Koa2的区别
Koa1使用generate，yield next方式执行promise异步操作，而Koa开始，使用aysnc/await来处理异步

### node http的不足
- 令人困惑的req和res
  - res.end()
  - res.writeHeader、res.setHeader   
- 描述复杂业务逻辑时不够优雅
  - 流程描述：比如a账号扣钱、b账号加钱
  - 切面描述(AOP)  比如鉴权、日志、加判断在某个时间开始打折促销，axios里的拦截。AOP实现分为语言级、框架级
```js
// 利用fs，渲染静态html、JSON字符串返回
const http = require('http')
const fs = require('fs')

const server = http.createServer((req, res)=> {
  const { url, method } = req
  console.log('url, method: ', url, method)

  if (url === '/' && method === 'GET') {
    fs.readFile('index.html', (err, data) => {
      if (err) throw err
      res.statusCode = 200
      res.setHeader('Content-Type', 'text/html')
      res.end(data)
    })
  } else if (url === '/users' && method === 'GET') {
    res.writeHead(200, {
      'Content-Type': 'application/json'
    })
    res.end(JSON.stringify({
      name: 'guoqzuo'
    }))
  }
})

server.listen(3003)
```
### koa优雅处理http
运行下面的代码，访问http://127.0.0.1 就可以看到 {name: 'Tom'} 内容
```js
// 需要先 npm install koa --save
const Koa = require('koa')
const app = new Koa()

app.use((ctx, next) => {
  ctx.body = {
    name: 'Tom'
  }
})

app.listen(3000)
```
#### ctx与next
下面的例子访问 http://127.0.0.1 为 {name: 'Tom'}，访问 http://127.0.0.1/html 内容为 '你的名字是Tom'
```js
const Koa = require('koa')
const app = new Koa()

app.use((ctx, next) => {
  ctx.body = {
    name: 'Tom'
  }
  next() // 执行下一个中间件
})

app.use((ctx, next) => {
  console.log(ctx.url)
  if (ctx.url === '/html') {
    ctx.body = `你的名字是${ctx.body.name}`
  }
})

app.listen(3000)
```
#### await next()
```js
const Koa = require('koa')
const app = new Koa()

// 也会被请求 /favicon.ico

app.use(async (ctx, next) => {
  // log日志
  let dateS = +(new Date())

  await next() // 先去处理后面的中间件，都处理完后再向下执行

  let dateE = +(new Date())
  console.log(`请求耗时${dateE - dateS}ms`)
})

app.use((ctx, next) => {
  ctx.body = {
    name: 'Tom'
  }
  next()
})

app.use((ctx, next) => {
  console.log(ctx.url)
  if (ctx.url === '/html') {
    ctx.body = `你的名字是${ctx.body.name}`
  }
})

app.listen(3000)
```

## Koa原理
### http服务
#### node与koa开启http服务方法
```js
// node http服务
const http = require('http')
const server = http.createServer(() => {
  res.writeHead(200)
  res.end('hello')
})
server.llsten(3000, () => {
  console.log('监听端口3000')
})

// koa http服务
const Koa = require('koa')
const app = new Koa()
app.use((ctx, next) => {
  ctx.body = {
    name: 'Tom'
  }
})
app.listen(3000)
```
#### 创建mykoa.js来模拟实现koa
先写好使用demo
```js
const MyKoa = require('./myKoa')
const app = new MyKoa()

// koa调用
// app.use((ctx, next) => {
//   ctx.body = {
//     name: 'Tom'
//   }
// })

// 先暂时简单点
app.use((req, res) => {
  console.log('执行了app.use')
  res.end('hello')
})

app.listen(3000, (err, data) => {
  console.log('监听端口3000')
})
```
myKoa.js实现
```js
// myKoa.js
const http = require('http')

class MyKoa {
  // app.use 调用 app.use(callback)
  use(callback) {
    this.callback = callback
  }

  listen(...args) {
    console.log(args)
    const server = http.createServer((req, res) => {
      this.callback(req, res)
    })
    server.listen(...args)
  }
}

module.exports = MyKoa
```
#### ctx参数(context)
一般app.use回调函数参数为 ctx和next，这里的ctx是context上下文的简写，主要是为了简化API而引入的。将原始请求对象req和响应对象res封装并挂载到context上，并在context上设置getter和setter属性，从而简化操作

getter和setter作用：
1. echarts中对于对象层级很深的属性，options.a.b.c，可以直接创建一个getter，这样写-法更优雅
2. vue2.0双向绑定

```js
// 更近一步 将app.use((req, res) => {}) => app.use(ctx => {})
app.use(ctx => {
  ctx.body = 'hello'
})
```
先看看koa源码 [koa -response源码](https://github.com/koajs/koa/blob/master/lib/response.js?1578238148633)

response最核心的一个方法是 set body方法，ctx.body 默认接收是json数据，如果传入了buffer、string、流都会有相应的处理

学着尝试封装request、response、context

```js
// demo app.js
const MyKoa = require('./myKoa')
const app = new MyKoa()

app.use((ctx) => {
  // console.log(ctx)
  ctx.body = 'hello'
})

app.listen(3000, (err, data) => {
  console.log('监听端口3000')
})

// myKoa.js
const http = require('http')
const context = require('./context')
const request = require('./request')
const response = require('./response')

class MyKoa {
  // app.use 调用 app.use(callback)
  use(callback) {
    this.callback = callback
  }

  listen(...args) {
    console.log(args)
    const server = http.createServer((req, res) => {
      //this.callback(req, res)
      // 需要先创建上下文
      let ctx = this.createContext(req, res)
      this.callback(ctx)
      res.end(ctx.body)
    })
    server.listen(...args)
  }

  // 将res和req封装到contxt
  createContext(req, res) {
    // 先继承一些我们写的对象
    const ctx = Object.create(context)
    ctx.request = Object.create(request)
    ctx.response = Object.create(response)

    ctx.req = ctx.request.req = req
    ctx.res = ctx.response.res = res

    return ctx
  }
}

module.exports = MyKoa
```
request.js
```js
module.exports = {
  get url() {
    return this.req.url
  },
  get method() {
    return this.req.method.toLowerCase()
  }
}
```
response.js
```js
module.exports = {
  get body() {
    return this._body
  },
  set body(val) {
    this._body = val
  }
}
```
context.js
```js
module.exports = {
  get rul() {
    return this.request.url
  },
  get body() {
    return this.response.body
  },
  set body(val) {
    this.response.body = val
  },
  get method() {
    return this.request.method  
  }
}
```

#### 中间件