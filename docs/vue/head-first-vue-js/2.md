# 第一篇 变化侦测

> Fork [vuejs/vue - github](https://github.com/vuejs/vue)，切换到 2.7.x 之前的最后一个版本，v2.6.14，因为 2.7 开始增加了一些和 vue3 类似的 API， 而且将 js 改成了 ts，增加了代码量，看 vue2 源码 2.6 的版本比较合适

对应 [src/core/observer - vue](https://github.com/zuoxiaobai/vue/tree/main/src/core/observer) (/əbˈzɜːvə(r)/) 目录

核心是 Watcher (/ˈwɒtʃə(r)/ 观察者) 和 Dep（Dependence 依赖）

## 2. Object 的变化侦测

### 2.1 什么是变化侦测

简单来讲，就是监听数据的变化，进行页面更新。

Vue.js 会通过状态（data 数据）生成 DOM，并显示到页面，这个过程叫渲染。

> 为了方便理解后面会将 状态 简单的描述为 data 数据。

在运行时，应用内部不断发生变化，需要不停的重新渲染，怎么判断是那些 data 发生了变化呢？

变化侦测就是用来解决这个问题的，它分为两种类型：

- push Vue 中使用的方式，当 data 发生变化，vue 会立即知道，并知道哪些数据变了，可以进行更细粒度的更新。
- pull  React 和 Angular 中变化侦测使用的方式，data 变化时，它不知道具体哪个 data 变了，会进行一个暴力比对来找出那些 DOM 节点需要重新渲染。Angular 中对应脏检查流程，React 中使用的是虚拟 DOM

但是粒度越细，每个状态所绑定的依赖越多，内存开销越大。因此 Vue 2.0 版本引入了虚拟 DOM，将粒度调整为中等粒度。

一个 data 绑定的依赖不再是具体的 DOM 节点，而是一个组件。状态变化后会通知组件，组件内部进行虚拟 DOM 比对，大大降低依赖数量，减少内存消耗。

### 2.2 如何追踪变化 defineReactive

Vue2 使用 Object.defineProperty 来监测对象的变化。

下面的 defineReactive 是对 Object.defineProperty 的封装

- 每当从 data 的 key 中读数据时，get 函数会触发
- 每当往 data 的 key 中设置数据时，set 会触发

```js
function defineReactive(data, key, val) {
    Object.defineProperty(data, key, {
        enumerable: true, // /ɪˈnjuːm(ə)rəb(ə)l/
        configurable: true,
        get: function () {
            return val
        },
        set: function (newVal) {
            if (val === newVal) {
                return
            }
            val = newVal
        }
    })
}
```

### 2.3如何收集依赖

收集依赖就是先收集哪些地方用到了 data 数据。方便后面数据更新后，再通知这些依赖进行更新。

一般在 template、watch、computed 中使用 data，数据变化后需要及时通知更新。methods 不用通知。

比如下面的例子中，先把用到数据 name 的地方收集起来，然后等数据发生变化时，把之前的依赖循环触发一遍即可。

```html
<template>
    <h1>{{ name }}</h1>
</template>
```

### 2.4 依赖收集在哪里（Dep）

创建一个 Dep 类（Dependence），用来存放依赖。

依赖可以是 template 里面的数据，也可能是 computed、watch。可以把依赖抽象成一个 Watcher 类。

一个 watcher 实例就是一个依赖，保存在 window.target 上（实际源码中是 Dep.target）

```js
export default class Dep {
    constructor() {
        this.subs = [] // this.subscribes = []  subscribes 订阅
    }
    // 添加一个订阅，即依赖实例
    addSub(sub) { this.subs.push(sub) }
    // 移除一个依赖，remove 是移除一个数据中的一个元素
    removeSub(sub) { remote(this.subs, sub) } 
    // 添加依赖 const dep = new Dep(); dep.depend() 
    depend() {
        window.target && this.addSub(window.target)
    }
    // setter 后通知，遍历所有依赖，触发依赖更新
    notify() {
        const subs = this.subs.slice()
        for (let i = 0, len = subs.length; i < 1; i++) {
            subs[i].update()
        }
    }
}
```

### 2.5(6) 把依赖抽象为 Watcher 类

Watcher 是对 template/watch/computed 中依赖的一个抽象，以下面的 watch 为例，来看 Watcher 实现

```js
vm.$watch('a.b,c', function(newVal, oldVal) {
    // a.b.c 变化后，执行一些操作
})
```

```js
export default class Watcher {
    constructor(vm, expOrFn, cb) {
        this.vm = vm
        this.getter = parsePath(expOrFn) // parsePath('a.b.c')，可以理解为获取 data.a.b.c 的值
        this.cb = cb   // function(newVal, oldVal) { // a.b.c 变化后，执行一些操作 }
        this.value = this.get()
    }

    // this.value = this.get()
    get() {
        // 下面三句话，不好理解，需要结合 Dep 类，Observer 类，parsePath 的实现来理解
        // 后面将 Observer 介绍完后，再来看这里的代码就好理解了
        window.target = this 
        let value = this.getter.call(this.vm, this.vm)
        window.target = undefined
        return value
    }

    update() {
        const oldVal = this.value
        this.value = this.get()
        this.cb.call(this.vm, this.value, oldVal)
    }
}
```

其中 parsePath 大致实现如下

```js
const bailRE = /[^\w.$]/ // 解析简单路径 
// \w 是 [0-9a-zA-Z_] 的简写，表示数字、字母、下划线
// . 匹配除 \n 外的任意一个字符，表示匹配非数字字母下划线的字符，即非法字符
export function parsePath(path) {
    if (bailRE.test(path)) {
        return
    }
    const segments = path.split('.')  // 例如 ['a', 'b', 'c']
    // 返回一个函数，即上面 this.getter 函数，
    // parsePath('a.b.c')(this.vm)，这里的 obj 就是组件实例 vm，即 this.a.b.c
    return function (obj) {
        for (let i = 0, len = segments.length; i < len; i++) {
            if (!obj) return
            obj = obj[segments[i]]
        }
        return obj
    }
}
```

### 2.7 变化侦测 defineReactive 封装 Observer 类

```js
export class Observer {
    constructor(value) {
        this.value = value
         if (!Array.isArray(value)) {
            this.walk(value) // 如果是非数组，即对象
        }
    }
    // walk 将对象的每一个属性都转换成 getter/setter 形式来侦测变化
    // 只有在数据类型为 Object 时调用
    walk(obj) {
        const keys = Object.keys(obj)
        for (let i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i], obj[keys[i]])
        }
    }
}

function defineReactive(data, key, val) {
    // 如果对象的属性也是对象，递归 Observer
    if (typeof val === 'obj') {
        new Observer(val)
    }
    let dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true, // /ɪˈnjuːm(ə)rəb(ə)l/
        configurable: true,
        get: function () {
            dep.depend() // 将依赖存到 Dep 中
            return val
        },
        set: function (newVal) {
            if (val === newVal) {
                return
            }
            val = newVal
            dep.notify() // 通过 Dep 通知依赖更新
        }
    })
}
```

这里重新来看 Watcher 的 get 方法，理解为什么要这么写

- this.getter.call(this.vm) 执行的是 parsePath(expOrFn)(this.vm)，vm 可以理解为组件实例
- this.vm.a.b.c 相当于读取组件中的 data.a.b.c 数据，一般所有的 object 数据都会通过 walk 函数，转换为 getter/setter 形式。读取数据会触发 Observer 中 defineReactive 中的 get 方法。
- get 方法中，会调用 dep.depend() 收集依赖，存到 Dep 中，而依赖是一个 watcher 实例，放在 window.target 上
- 这也是，为什么在 this.getter.call(this.vm) 之前需要设置 window.target = this 的原因。正好把当前依赖实例赋值到了 window.target 上，在 dep.depend() 内部执行 this.addSub(window.target)，将依赖存放到 Dep 中的 this.subs
- watch('a.b.c', cb) 这个依赖收集完成后，将 window.target 再置空，方便收集下一个依赖
- 另外，Observer denfineReactive 中，setter 方法触发，会执行 depend.notify()，会遍历 this.subs 中存放的 watcher 依赖实例执行 update 方法。即 下面 watcher update 中的 cb 回调函数

```js
export default class Watcher {
    constructor(vm, expOrFn, cb) {
        this.vm = vm
        this.getter = parsePath(expOrFn) // parsePath('a.b.c')，可以理解为获取 data.a.b.c 的值
        this.cb = cb   // function(newVal, oldVal) { // a.b.c 变化后，执行一些操作 }
        this.value = this.get()
    }

    // this.value = this.get()
    get() {
        // 下面三句话，不好理解，需要结合 Dep 类，Observer 类，parsePath 的实现来理解
        window.target = this 
        let value = this.getter.call(this.vm, this.vm)
        window.target = undefined
        return value
    }

    update() {
        const oldVal = this.value
        this.value = this.get()
        this.cb.call(this.vm, this.value, oldVal)
    }
}
```

### Observer, Dep, Watcher 的调用时机

变化侦测，核心是 Observer、Dep、Watcher 这三个类

- Observer 将 data 数据转换为 getter/setter，拦截数据的读和写，get 读数据时，收集依赖存放到 Dep，set 时通知 Dep 中存放的依赖进行更新
- Dep 专门用于存放收集到的依赖，还可以通知依赖进行更新
- Watcher 是对依赖的抽象，一个依赖对应一个 watcher 实例，每一个 template、computed、watch、指令 中使用的 data 数据，都是一个依赖

调用时机问题

- 首先应该是遍历 data 数据，调用 Observer 类的 defineReactive 对每一个属性进行 getter/setter 拦截，初始化一个存放依赖的 Dep 实例，get 方法触发时添加依赖(dep.depend())，set 方法时通知依赖更新(dep.notify())
- template 模板编译、处理声明的 watch、computed 时，对于每一个 data 相关属性，都调用 Watcher，初始化一个 watcher 实例，在实例初始化的 constructor 方法时，通过读取一次对应的 data 值，触发对应 getter 方法，将当前依赖的 watcher 实例通过 dep.depend() 存放到 dep 中
- 另外 this.data.xxx 更新时，触发 setter 方法，会 dep.notify，通知 watcher 实例进行 update，update 会调用 cb(newVal, oldVal) 进行更新。

SFC 单文件组件

```html
<template>
    <div>{{name}}</div>
</template>
<script>
export default {
    data () {
        return {
            a: { b: { c: 1} },
            name: 'test'
        }
    },
    watch: {
        'a.b.c': function (val, oldVal) {
            // 做些什么
        }
    },
    computed: {
        composeVal() {
            return this.a.b.c + this.name
        }
    }
}
</script>
```

纯 html

```html
<html>
<div id="app">
    <div>{{name}}</div>
</div>
<script>
let app = new Vue({
    el: '#app',
    data () {
        return {
            a: { b: { c: 1} },
            name: 'test'
        }
    },
    watch: {
        'a.b.c': function (val, oldVal) {
            // 做些什么
        }
    },
    computed: {
        composeVal() {
            return this.a.b.c + this.name
        }
    }
})
</script>
</html>
```

### 2.8 关于 object 的问题

前面介绍了变化侦测的原理，在遍历 data 数据调用 Observer 将数据转换为 getter/setter，来追踪变化，但如果在后面动态添加了 data 属性，会导致追踪不到这个属性的变化，来看一个例子

```js
const app = new Vue({
    el: '#app',
    data() {
        return {
            obj: {
                age: 18
            }
        }
    }
    methods: {
        action() {
            this.obj.name = 'Brook'
        },
        del() {
            delete this.obj.age
        }
    }
})
```

上面的例子中使用方法，添加一个新的属性，或者删除原有的属性，Vue 无法监测到这个变化，也不会向依赖发送更新通知。

对于这种情况，需要使用 vm.$set 与 vm.$delete 来添加或删除响应式依赖，后面第 4 章会讲到

### 2.9 总结

- 变化侦测就是侦测数据的变化，数据变化时，能侦测到并发送通知
- Object 可以通过 Object.defineProperty 将属性转换为 getter/setter 形式来追踪变化，读取时触发 get，修改时触发 set
- 在 get 中收集依赖，在 set 中，通知依赖进行更新
- 收集依赖需要一个存放的地方，为此创建了 Dep 类型，用来添加/删除依赖，向依赖发送消息、
- 将依赖抽象为一个 watcher 实例

![head-first-vue-js-observer.png](/images/vue/head-first-vue/head-first-vue-js-observer.png)

## Object 变化侦测 demo

考虑到后面的数组变化侦测更加复杂，不能仅靠理论代码来揣摩代码运行逻辑。这里通过一个 demo 来将 Object 变化侦测涉及到的逻辑都串起来，能够跑通逻辑，方便后面理解。

目录结构如下，完整代码地址：[vue2/my-vue/observer - vue2-implement](https://github.com/zuoxiaobai/vue2-implement/tree/vue2/my-vue)

```bash
my-vue
├── index # 入口
├── observer # 观察者，依赖监听
│   ├── dep.js  # 依赖存放
│   ├── observer.js # 转换为 setter/getter 收集依赖/通知更新
│   ├── watcher.js # 依赖实例
```

测试代码

```js
// my-vue/index.js
import { Observer } from "./observer/observer.js";
import { Watcher } from "./observer/watcher.js";

class MyVue {
  constructor(options) {
    this.data = options.data();
    // 1、遍历 data，调用 Observer 转换为 getter/setter, 拦截处理
    const observerData = new Observer(this.data);
    console.log("observerData", observerData);

    // 2、收集依赖（模板、watch哪些地方用到了 data 数据，每一个地方就是一个依赖实例
    // > 2.1 template 处理，省略 complier 部分，模板里面有使用 name, a 两个变量
    const domUpdate = (name) => {
      return (val, oldVal) => {
        console.log(
          `${name} 数据变化，新值: ${val}, 旧值: ${oldVal} 假装执行dom更新`
        );
      };
    };
    new Watcher(this.data, "name", domUpdate("name"));
    new Watcher(this.data, "a", domUpdate("a"));
    // > 2.2 watch 处理
    Object.keys(options.watch).forEach((prop) => {
      let val = options.watch[prop];
      // new Watcher(this.data, 'a.b.c', options.watch['a.b.c'].handler)
      new Watcher(this.data, prop, val?.handler || val);
    });
  }
}

// observer 功能测试
const app = new MyVue({
  template: "<div>{{ name }}</div><div>{{ a }}</div>",
  data() {
    return {
      a: { b: { c: 1 } },
      name: "123",
    };
  },
  watch: {
    "a.b.c": {
      handler(val, oldVal) {
        console.log("监听到 a.b.c 改动", val, oldVal);
      },
    },
  },
});

console.log("app", app);
// 修改数据，看是否侦测到数据变更
app.data.a.b.c = 123;
app.data.name = "test";
app.data.a = { b: { c: 777 } };
```

运行结果

```js
PS E:\clone\vue2-implement> node .\my-vue\index.js
observerData Observer { value: { a: [Getter/Setter], name: [Getter/Setter] } }
app MyVue { data: { a: [Getter/Setter], name: [Getter/Setter] } }
监听到 a.b.c 改动 123 1
name 数据变化，新值: test, 旧值: 123 假装执行dom更新
a 数据变化，新值: [object Object], 旧值: [object Object] 假装执行dom更新
监听到 a.b.c 改动 777 123
监听到 a.b.c 改动 777 777
PS E:\clone\vue2-implement>
```

- 其中 node xx.js 时不支持 import，在 package.json 里面加了 `"type": "module"` 才能正常运行。
- 知道了为什么 vue 源码使用的是 Dep.target 而不是书中的 window.target，因为 Node 并不支持 window，而是 globalThis
- node 运行的缺点在于不能在 console 里查看对象的完整内容，待将 demo 改造为 html 页面

## 3. Array 的变化侦测

Object 可以通过 getter/setter 方法侦测到数据变化，对应数组来说却行不通。

因为数组可以通过 Array 原型上的方法来改变数组内容，比如 this.list.push(1)，向数组中增加元素 1，并不会触发 getter/setter。

### 3.1 如何追踪变化

数组操作一般是调用 Array.prototype 上的原型方法（比如 push/pop等），重新这些方法，加拦截处理即可追踪数组的变化。

### 3.2 拦截器

Array 原型中可以改变数组自身内容的方法有七个：push/pop/shift/unshift/splice/sort/reverse

重写 Array 原型属性

```js
// 重写 7 个原型方法
let methods = ['push','pop','shift','unshift','splice','sort','reverse']
methods.forEach(item => {
    // 缓存原有方法
    let original = Array.prototype[item]
    // data: { list: [1, 2, 3] }
    // arr.splice() 不会改变数组，但可以触发数组的响应式更新刷新
    Array.prototype[item] =  function (...args)  {
        // this.list.push(4) 会走到这里，其中 this 为 [1, 2, 3]
        this.__ob__.dep.notify()
        console.log('做一些拦截处理')
        // 调用原有方法，和拦截之前行为保持一致
        return original(args)
    }
})
// this.list = 
```

### 3.3 使用拦截器覆盖 Array 原型

```js
export class Observer {
    constructor (value) {
        this.value = value
        this.dep = new Dep()
        value.__ob__ = this

        if (Array.isArray(value)) {
            value.__proto__ = customArrayPrototype
        } else {
            this.walk(value) // 如果是对象
        }
    }
}
```

```js
// // 创建一个自定义 Array 原型属性
// const customArrayPrototype = Object.create(Array.prototype); // 继承原先的原型

// // 重写 7 个原型方法
// let methodNames = ['push','pop','shift','unshift','splice','sort','reverse']
// methodNames.forEach(methodName => {
//     // 缓存原有方法
//     let original = Array.prototype[methodName]
//     customArrayPrototype[method] =  (...args) => {
//         console.log('做一些拦截处理')
//         // 调用原有方法，和拦截之前行为保持一致
//         return original(args)
//     }
// })
// // 用重写的原型对象覆盖默认的原型属性
// Array.prototype = customArrayPrototype
```

### 3.3

### 3.4
