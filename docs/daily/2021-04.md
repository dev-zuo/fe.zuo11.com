# 2021年04月技术日常
## 2021/04/25 周日
### v-model 怎么优雅的绑定 Vuex 状态管理中的值，三种方法优缺点
- 官方推荐：使用 computed 的 get 和 set
- 非严格模式：直接将 state 设置到 v-model
- 中间对象转换：watch 监听 state 改变，更新中间对象，v-model 中间对象

### String.prototype.replace 多个匹配替换时注意要使用正则
### Vue filters 中 this 无法使用，为什么？
### vue-i18n 国际化相关用法、实践总结
- 模块化
- 列表（code 值）
- 过滤器 filter
- 语言切换组件

### vue 组件中 css 路径简写 @ 不可用，需要使用 ~@，为什么？
### footer 始终保持在最底部 js 和 css 实现优缺点比较
```js
// :class="fixed ? 'flexd-bottom' : ''"
// data: { fixed: false }
let { clientHeight } = document.documentElement;
let { scrollHeight: pageScrollHeight } = document.querySlector('.main')
let { scrollHeight: bottomScrollHeight } = document.querySelector('.footer')
// 如果整体页面高度(包含默认加载的 bottom) < 视窗高度
if (pageScrollHeight < clientHeight) {
  this.fixed = true
}

// &.fixed-bottom {
//   position: absolute;
//   bottom: 0;
// }
```
### Vue 组件封装，通过发布订阅模式和 Vue 实例方法实现 js 操作组件
### 正则表达式使用 () 和 match 或 replace 提取 url 路径参数
来看一个问题，使用正则表达式从 url 中提取区域、城市id、模块、页数id。url 示例如下
1. `http://www.xx.com/region/gd/module`
2. `http://www.xx.com/region/gd-c222/module`
3. `http://www.xx.com/region/gd-c222/module/p2`

下面来看看怎么实现

首先，回顾下正则表达式（Regular Expression）基础。正则表表达式以 `/pattern/flags` 表示，是 RegExp 对象的实例

```js
/[a-z]*/g instanceof RegExp // true
```

pattern 模式由下面的字符组成
- `边界符号(^、$)` ^ 以 xx 开头，$ 以 xx 结尾
  - `/^abc/` 表示以 abc 开头
  - `/abc$/` 表示以 abc 结尾
- `字符集合([]、^、-)` 一系列的字符集合
  - `[abc]` 表示 abc 里面的任意一个字符
  - `[^abc]` 表示任意一个非 abc 字符，注意 ^ 在 [] 里面表示非 xx 字符
  - `[a-z0-9]` 表示 a 到 z 的字符，0 到 9 字符
- `预定义模式字符(.、\d、\w、\s、\n)` 一些常见字符集合的简写
  - `.` 表示除 \r\n 之外的所有字符
  - `\d` 是 `[0-9]` 的简写，表示数字
  - `\D` 是 `[^0-9]` 的简写，表示非数字
  - `\w` 是 `[0-9a-zA-Z_]` 的简写，表示数字、字母、下划线
  - `\W` 是 `[^0-9a-zA-Z_]` 的简写，表示非数字、字母、下划线
  - `\s` 是 `[ ]` 的简写，表示空白符(空格)，`"  a  b c   ".replace(/\s/g, '') === "abc"`
  - `\S` 是 `[^ ]` 的简写，表示非空白符
  - `\n` 表示 换行符

- `匹配次数/数量(?、*、+、{})`
  - `?` 匹配前面的模式 0 次或 1 次 {0, 1}
  - `*` 匹配前面的模式 0 次或多次 {0, }
  - `+` 匹配前面的模式 1 次或多次 {1, }
  - `{n}`	匹配前面的模式 n 次
  - `{n,m}` 匹配前面的模式 至少 n 次，至多 m 次
- `其他 ()、|`
  - `()` 用于匹配字符串中的多个部分，比如 `(\w+)\s(\w+)` 匹配 `aaa bbb`，第一部分 $1 为 'aaa'，第二部分 $2 为 'bbb'。可以使用 regExp.exec(str) 返回对象的 index 来获取对应的部分值。或者 replace 时，使用 $1 $2 等格式替代。
  - `|` 表示或 `/a|b/` 表示 a 或者 b 
- `转义字符* + ? $ ^ . | \ ( ) { } [ ]` 正则表达式保留字符都需要在前面加 `\` 进行转义，比如字符 `/` 需要使用 `\/` 表示

flags 标志位：g 不仅仅匹配第一个，全局匹配。i 忽略大小写

正则表达式中，一个 () 表示一个部分，来看一个例子。

```js
let str = "zuo guoqing"
let reg = /(\w+)\s(\w+)/ // 匹配两个部分 '第一部分 第二部分'
str.replace(reg, "$2 $1") // 将两个部分对调，"guoqing zuo"
str.match(reg) // { 0: "zuo guoqing", 1: "zuo", 2: "guoqing" }
reg.exec(str) // { 0: "zuo guoqing", 1: "zuo", 2: "guoqing" }
```

现在我们可以使用 () 来分部分（块）提取 url 中的字符了，将 url 拆解 `.com之前的部分\/区域部分\/城市以及id部分\/模块部分\/页数部分`
```js
// .com 之前的部分 [\S]+.com\/  匹配一个或多个非空白符.com\/
// 区域部分 ([\w]*)\/ 匹配 0 个 或多个 数字字母下划线
// 城市及id部分 ([\w-]*)\/ 匹配 0 个或多个 数字字母下划线 -
// 模块部分 ([\w]*)\/?
// 页数部分 ([\w]*)$
let regExp = /[\S]+.com\/([\w]*)\/([\w-]*)\/([\w]*)\/?([\w]*)$/
let a = `http://www.xx.com/region/gd/module`
let b = `http://www.xx.com/region/gd-c222/module`
let c = `http://www.xx.com/region/gd-c222/module/p2`
a.replace(regExp, '$1 $2 $3 $4') // "region gd module "
b.replace(regExp, '$1 $2 $3 $4') // "region gd-c222 module "
c.replace(regExp, '$1 $2 $3 $4') // "region gd-c222 module p2"
a.match(regExp) // { 1: "region", 2: "gd", 3: "module", 4: "" }
c.match(regExp) // { 1: "region", 2: "gd-c222", 3: "module", 4: "p2" }
```

## 2021/04/10 周六
### Make sure you configure your ‘user.name’ and ‘user.email’ in git
在 vscode 中，使用可视化工具，而非命令的方式提交代码时，如果没有配置 git 的 user.name 和 user.email，可能会弹出 Make sure you configure your ‘user.name’ and ‘user.email’ in git 的错误，代码无法提交。这就需要先配置好，再提交了。

另外，在 github 或 gitlab 等页面中，可能会遇到提交没有绿点或者看不到头像的情况，可能是因为配置的 user.email 发生了变化，和平台的 email 不一致导致的。修改成一致的就正常了。

下面来看看怎么设置 user.name 和 user.email。git 配置（configure）分两种，一种是全局的，一种是针对单个项目仓库的（项目目录下）。可以使用 git config 来管理管理配置（查看、设置）

**查看配置**

可以使用 git config --list 查看当前配置，如果没有 user.name，和 user.email，就说明还没有配置。
```bash
# 查看当前目录下项目的配置
git config --list
# credential.helper=osxkeychain
# user.name=zuoxiaobai
# user.email=guoqzuo@gmail.com
# remote.origin.url=git@github.com:zuoxiaobai/fenote.git
# remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
# branch.master.remote=origin
# branch.master.merge=refs/heads/master

# 查看全局配置
git config --list --global
# user.name=zuoxiaobai
# user.email=guoqzuo@gmail.com
# core.quotepath=false
```
**设置（修改配置）** 

可以使用 git config 属性名 属性值，来设置 git 配置，默认是项目内的（局部的），如果需要设置全局的，需要加上 --global，设置完成后，再使用查看配置的命令 git config --list 就可以看到配置生效了。
```bash
# 进入项目目录，单个仓库（项目），局部设置
git config user.name "zuoxiaobai" 
git config user.email "guoqzuo@gmail.com"

# 全局设置
git config --global user.name "zuoxiaobai" 
git config --global user.email "guoqzuo@gmail.com"
```

:::warning
注意 git config 属性名 属性值 时，如果属性值没有用双引号 "" 包裹，那么中间不能有空格，比如 git config user.name zuo xiaobai，相当于 git config user.name zuo，会丢弃空格后面的部分
:::

更多用法，可以使用 git config --help 查看帮助，或查看对应的官方文档 [Git - git-config Documentation](https://git-scm.com/docs/git-config)

### 用游戏中的场景理解节流与防抖，最简单的 js 实现

之前对节流(throttle) 和防抖（debounce）的理解有偏差，以为 ~~scroll 或 resize 时，为了减少执行事件函数频率，需要用节流，减少执行次数。而防抖在于点击某个按钮后，多长时间内不允许再次点击。防止多次重复提交表单，或执行下一步函数。~~

这种理解是反的。我们可以用游戏的中的场景来理解节流和防抖

**节流(throttle)** 

对应 **技能冷却时间**，如果冷却(cooldown/cd)是 5 秒，使用技能后，5秒内，无法再次执行。用于控制事件执行一次后，多长时间内不允许再次执行。一般用于防止按钮多次点击，重复触发事件。

![throttle.gif](/images/daily/throttle.gif)

来实现节流的功能，比较好的实现是，创建一个可复用的节流函数，它可以将普通函数转换为增加了节流功能的函数，基本结构如下
```js
/**
 * throttle
 * @param { Function } func 执行函数
 * @param { Interger } time 多长时间内不能第二次执行
 * @returns function 返回经过节流处理的函数
 */
function throttle(func, time) {
  return (...args) => {
    // 返回一个可以正常执行的函数
    func.apply(this, args)
  }
}
```
在基本的机构中，增加节流控制处理
```js
/**
 * throttle
 * @param { Function } func 执行函数
 * @param { Interger } time 多长时间内不能第二次执行
 * @returns function 返回经过节流处理的函数
 */
function throttle(func, time) {
  let isLock = false // 是否冷却(cooldown)中
  // 返回一个经过节流处理的 func
  return function (...args) {
    if (isLock) { // 如果是冷却中，不执行函数
      console.log('冷却(cd)中...')
      return 
    }
    // 非冷却中
    func.apply(this, args) // 执行函数
    isLock = true // 执行函数后设置为冷却中
    setTimeout(() => {
      isLock = false // 经过 time 微秒后，设置为非冷却中
    }, time);
  }
}
```

使用示例
```html
<button id="skillsABtn">释放技能A</button>
<script>
  let skillsABtn = document.querySelector('#skillsABtn')
  releaseASkills = () => {
    console.log(`释放A技能, ${+new Date()}`)
  }
  // 技能冷却时间 3 秒
  skillsABtn.onclick = throttle(releaseASkills, 3000)
</script>
```

**防抖(去抖动 debounce、de + bounce)** 

对应 **回城**，在推塔游戏中，回城等待时间是 8 秒。可以理解为回城时，会开启一个定时任务，8 秒后执行完成回城的函数。

防抖/去抖动，就是在定时任务等待执行的时间内，如果再次触发发了函数，会取消上一次的定时任务，重新开始一个定时任务。这样可以**将一段时间内连续的多次触发转化为一次触发，单位时间内仅执行最后一次**。一般用于 window 的 scroll、resize 事件、搜索框输入搜索内容后实时查询接口等。

```js
function debounce(func, time) {
  let timer = null // 定时任务计时器
  // 返回一个经过防抖处理的 func
  return function (...args) {
    if (timer) {
      // 如果上一次定时任务还在等待执行的过程中，取消定时任务
      clearTimeout(timer)
      console.log('取消上一次的计时任务')
    }

    console.log(`重新开启定时任务，${time} 毫秒后真正执行`)
    timer = setTimeout(() => {
      func.apply(this, args)
    }, time);
  }
}
```
实例
```html
<button id="goBackBtn">回城</button>
<script>
  let goBackBtn = document.querySelector('#goBackBtn')
  goBack = () => {
    console.log(`成功回城, ${+new Date()}`)
  }
  // 3 秒之后回城
  goBackBtn.onclick = debounce(goBack, 3000) 
</script>
```

完整 demo 示例代码：[节流和防抖实现 - fedemo | Github](https://github.com/zuoxiaobai/fedemo/tree/master/src/DebugDemo/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E5%AE%9E%E7%8E%B0)，在线示例 [节流与防抖简单实现 demo - 需要打开 console 看执行效果](https://zuoxiaobai.github.io/fedemo/src/DebugDemo/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%E5%AE%9E%E7%8E%B0/#/)
## 2021/04/06 周二
### props Right-hand side of 'instanceof' is not an object
在 Vue 中写 props 属性时，一般最简单的方式是使用数组的形式： props: ['属性名1', '属性名2']，但这样没有类型校验、默认值。在使用对象的写法时，发现出现 props Right-hand side of 'instanceof' is not an object，错误，写法如下

```js
export default {
  props: {
    tips: {
      type: “Array”,
      default: () => []
    }
  }
}
```

后面发现是 type 属性设置的有问题。限定为数组，Array 类型，直接用 Array 就行，不要加引号，它不是字符串，而是对象 object（类）。
```js
tips: {
  type: Array,
  default: () => []
}
```

参考: [Prop 验证 — Vue.js](https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81)

### 小程序代码丢失后，代码找回过程记录（反编译、云开发函数恢复）
最近想把之前写的一个已上线的小程序开源，发现当时居然没有用 git 管理，换电脑、折腾 mac 双系统后，代码丢失了。尝试用数据恢复软件恢复都没有找回代码，尽管小程序的文件特征很好找，比如 .wxml、project.config.json 等。

后面在网上找了反编译线上小程序的方法。这样可以拿到 uglify 混淆压缩后的代码，至少比没有强。另外，云函数的代码也是可以恢复的，因为之前开发时上传过，它是可以下载的。

:::warning
注意：反编译小程序要求必须是已上线的小程序。对于云函数的恢复/下载，需要知道之前开发的 appid，且微信账号拥有对应的管理员/开发权限。
:::

**为什么小程序可以反编译？**

理论上小程序也是属于前端代码，前端的 js、css、html 一般是可以拿到的。微信在打开小程序时，会先下载对应小程序的包(.wxapkg文件)来执行。只要我们拿到这个文件，就可以通过反编译拿到混淆压缩后的代码。这里反编译使用的是 [wxappUnpacker](https://github.com/qwerty472123/wxappUnpacker)，虽然删除了，但点开 fork，有很多之前备份的代码。 

**获取小程序的 wxapkg 文件**

1. 下载安装 [夜神模拟器](https://www.yeshen.com/)，注意：如果是 mac 系统，打开后一直卡在 99%，可能是因为 VirtualBox 的原因，安装该模拟器时，会自动安装 VirtualBox，可以在 app 中手动打开 VirtualBox 并启动，再打开模拟器。
2. 下载 [RE 文件管理器](http://www.pc6.com/az/56118.html)，文件名为：com.speedsoftware.rootexplorer_999496.apk
3. 在 模拟器中 安装 RE文件管理器，点击模拟器右侧的 添加 apk 文件图标，选择刚才下好的 apk 文件进行安装。如下图，安装完成后打开该 app，并允许获取权限。

![wxapkg_1_1.png](/images/daily/wxapkg_1_1.png)

4. 在模拟器中搜索 微信，安装好后，运行微信，登录后，打开对应的小程序
5. 打开小程序后，在文件管理器的 `/data/data/com.tencent.mm/MicroMsg/{数字串}/appbrand/pkg/` 目录，可以看到对应的 .wxapkg 文件，如下图。注意：如果找不到对应的文件，可以点击右上角的三个点，搜索对应的文件。

![wxapkg_1_2.png](/images/daily/wxapkg_1_2.png)

6. 导出 .wxapkg 文件。鼠标长按对应的文件，多选两个 wxapkg 文件，点击右上角三个点，zip 压缩，压缩后，查看对应的文件，再点击右上角三个点，发送到微信即可。 

![wxapkg_1_3.png](/images/daily/wxapkg_1_3.png)

**使用 wxappUnpacker 反编译 wxapkg 文件**

拿到小程序的 wxapkg 文件后，我们将之前在 fork 仓库中下载好的 wxappUnpacker 在 vscode 中打开，使用 Terminal cd（进入）到对应的目录。运行 npm install 或 yarn add 安装对应的依赖。安装完成后，在当前目录下，运行 `node wuWxapkg.js 对应的小程序wxapkg文件` 命令，就可以得到反编译后的代码。
```bash
# 安装依赖
npm install css-tree cssbeautify escodegen esprima js-beautify uglify-es vm2
# 还原小程序代码示例
node wuWxapkg.js '/Users/zuo/Desktop/test1234/_626200936_1.wxapkg'
```

运行后，虽然生成了代码，但是 terminal 出现了下面的错误，css 文件未被还原

```js
/wxappUnpacker-master/node_modules/vm2/lib/main.js:890
                                throw this._internal.Decontextify.value(e);
                                ^
ReferenceError [Error]: __vd_version_info__ is not defined
```

这里需要修改 wxappUnpacker 项目中 wuWxss.js 中的 runOnce() 函数代码
```js
// wuWxss.js
// function runOnce(){
// 	for(let name in runList)runVM(name,runList[name]);
// }
function runOnce() {
  for (let name in runList) {
    // console.log(name, runList[name]);
    var start = `var window = window || {}; var __pageFrameStartTime__ = Date.now(); var __webviewId__; var __wxAppCode__={}; var __mainPageFrameReady__ = function(){}; var __WXML_GLOBAL__={entrys:{},defines:{},modules:{},ops:[],wxs_nf_init:undefined,total_ops:0}; var __vd_version_info__=__vd_version_info__||{};
    
    $gwx=function(path,global){
    
    if(typeof global === 'undefined') global={};if(typeof __WXML_GLOBAL__ === 'undefined') {__WXML_GLOBAL__={};
    
    }__WXML_GLOBAL__.modules = __WXML_GLOBAL__.modules || {};
    
    }`;
    runVM(name, start + " \r\n" + runList[name]);
  }
}
```

修改后再次执行就 OK 了，代码大致就恢复了。目录结构如下

![wxapkg_2_1.png](/images/daily/wxapkg_2_1.png)


**小程序云开发，云函数代码恢复**

:::warning
理论上云开发和小程序 appid，微信号开发权限是相关联的，如果没有权限是无法还原云函数的
:::

这个项目是小程序云开发的项目，而 wxappUnpacker 恢复的只是普通小程序的目录结构。下面是小程序云开发的目录结构

![wxapkg_2_2.png](/images/daily/wxapkg_2_2.png)

我们需要进一步处理
1. 创建一个新的文件夹，比如 my-app，然后在目录下创建 cloudfunctions 和 miniprogram 文件夹，将恢复的代码，拷贝到 miniprogram 中
2. 创建 project.config.json 文件，找到之前开发该小程序时，使用的该小程序的 appid，修改 project.config.json 文件

```js
{
  "miniprogramRoot": "miniprogram/",
  "cloudfunctionRoot": "cloudfunctions/",
  "appid": "wx45333c9fc02af773",
  "projectname": "my-app"
}
```
3. 打开微信小程序开发工具，选择导入项目，选择 my-app 目录，即可打开项目，如下图

![wxapkg_3_1.png](/images/daily/wxapkg_3_1.png)

由于我们之前创建过云开发环境，因此我们右键 cloudfunctions 目录，可以选择当前环境比如 test。这时 cloudfunctions 是空的，可以右键后，选择同步云函数列表

![wxapkg_3_2.png](/images/daily/wxapkg_3_2.png)

同步后，cloudfunctions 目录下就会创建之前的云函数文件夹，如下图，右键对应的云函数文件夹，选择下载，即可下载对应云函数的代码。

![wxapkg_3_3.png](/images/daily/wxapkg_3_3.png)

云函数代码，不是混淆压缩的，是 100% 还原的，如下图

![wxapkg_3_4.png](/images/daily/wxapkg_3_4.png)

自此，项目就大致还原了。美中不足的是，样式没有恢复完全，另外 js 都是混淆压缩后的代码，需要慢慢修改还原。

不过项目还是可以跑起来的，比完全丢失了好，还原后的该小程序已开源，后面会慢慢修复还原混淆压缩后的代码。开源地址：[remicade-record - github](https://github.com/ibdlib/remicade-record)

参考: 
- [小程序源码丢失了怎么在微信平台反编译找回](https://blog.csdn.net/qq_38822390/article/details/82152004)
- [最新解决小程序反编译$gwx is not defined和__vd_version_info__ is not defined](https://www.jianshu.com/p/83b9e7d3ded4)
- [2020微信小程序反编译（逆向），仅用于学习请勿商用](https://www.cnblogs.com/yeahwell/p/13546770.html)

### 提示 hints、tips、prompt 以及 message 的区别 
在程序开发中，关于提示组件的命名，有 tips、hints、prompt、message 等，一般怎么使用呢？下面来看看

- **tips**，n. 小贴士、温馨提示、小窍门。**主要用于文字提示**，比如 tooltip 组件。

- **hints**，n. 暗示、提示，v. 暗示、示意。开发中用的较少，相比于 tips，**它有间接含蓄, 暗示，不直接提示**的意思。

- **prompt**，n. 提示、提词，v. 提示、鼓励、促进。在开发中用的较少，BOM API 中带输入框的提示，使用的就是 prompt `window.prompt('最近还好吗？')`

- **message** n. 消息、信息，v. 通知。**主要是全局提示，强调信息、消息**。收到一条通知、消息。常用于 message 消息/信息提示/显示。

另外还有一个 alert，属于 **警告提示**。

参考: [英语hints和tips区别？](https://zhidao.baidu.com/question/2144372129649021108.html)