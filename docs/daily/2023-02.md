# 2023 年 02 月

## 2023-02-06

### 一个 dialog 占 1G 内存？vue3 的一个内存泄漏bug

[[Component] [dialog] dialog组件导致内存泄漏](https://github.com/element-plus/element-plus/issues/8972)

vue 相关问题？

The onUnmounted callback is not triggered when using Teleport

<https://github.com/vuejs/core/issues/6347>

### 什么是 swc? parcel 2 使用它替代 js 打包性能提升 10 倍？

[Parcel 2 beta 3](https://parceljs.org/blog/beta3)

10x faster JavaScript compiler written in Rus

### smooth-scrolling 平滑滚动产生的 bug

table 纵向懒加载时候，默认滚动到最下面，需要滚动到之前的位置，直接修改 scrollTop 会触发平滑滚动

但我的电脑有点问题，平滑滚动效果是关的，导致滚动有问题，怎么在滚动的时候关闭平滑滚动效果，以及怎么配置浏览器开启平滑滚动效果

chrome://flags/#enable-smooth-scrolling

### 通过 vue3 的两个历史 bug，来了解正则 s 标志位的用处

正则表达式格式为 `/pattern/flags`, flags 标志位：g 不仅仅匹配第一个，全局匹配。i 忽略大小写。

根据 vuejs 的一个 bug 来看 s 标志位的应用场景。

s 标志位的使用场景：

- 正则表达式的模式匹配中，`.` 默认可以匹配除 `\n` 外的任意一个字符。
- 如果加了 `/s` 标志位，`.` 就可以匹配全部字符了，包括 `\n`

vue3 的源码中，有一个 `.` 无法匹配换行符 (`\n`) 导致的 bug，下面来看看，以下是 PR 链接

[fix(shared): parse multi-line inline style by sxzz · Pull Request #6777 · vuejs/core](https://github.com/vuejs/core/pull/6777)

![regex-s-flag.png](/images/daily/regex-s-flag.png)

如下图，再没有修复这个 bug 前，下面的多行内联样式，在 `padding-box,` 位置会结束，后面的内容会匹配不到

```js
<div style="
      border: 1px solid transparent;
      background: linear-gradient(white, white) padding-box,
        repeating-linear-gradient(
          -45deg,
          #ccc 0,
          #ccc 0.5em,
          white 0,
          white 0.75em
        );
    ">
</div>
```

之前使用的正则是，`(.+)` 匹配不到换行

```js
const propertyDelimiterRE = /:(.+)/
```

中间 尤雨溪 加了如下改动，链接

```js
const propertyDelimiterRE = /:(.+)/s 
// 删除上面这一行，这里加了 s 标志位，但是有位置的单元测试过不去，
// 最后改为下面这一行，链接 https://github.com/vuejs/core/pull/6777/commits/2a50d03e5c6a737a860de349e0df16743c654582
const propertyDelimiterRE = /:([^]+)/
```

文件地址：<https://github.com/vuejs/core/blob/main/packages/shared/src/normalizeProp.ts>

再来看下面一个 bug，vue 3.2.40 版本中 style 内联样式中注释下面的一行样式会不生效。["Inline style regular doesn't work when below comments · Issue #6807 · vuejs/core"](https://github.com/vuejs/core/issues/6807)

```html
  <div
    style="
      /* something */
      width: 300px;
      height: 300px;
      background-color: pink;
    "
  ></div>
```

解决方法如下，使用正则匹配 style 中的评论，然后删除，也用到了额 s 标志位

```js
const styleCommentRE = /\/\*.*?\*\//gs
// /* .*? */
export function parseStringStyle(cssText: string): NormalizedStyle {
  const ret: NormalizedStyle = {}
  cssText
    .replace(styleCommentRE, '') // 将 style 内容中的注释内容删除
    .split(listDelimiterRE)
    .forEach(item => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE)
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())
      }
    })
  return ret
}

```

## 2023-02-05

### Find X3 火星版官网动效实现

[OPPO Find X3 Pro 火星探索版 有色彩的地方 就有让生命感动的力量 | OPPO 官方网站](https://www.oppo.com/cn/smartphones/series-find-x/find-x3-pro-mars/)

效果预览：[nice.zuo11.com](http://nice.zuo11.com)

![find_x3_section1-2.gif](/images/daily/find_x3_section1-2.gif)

1、首屏是一个 video 动画，没有加 loop，比较简单

2、第二屏也是一个 video 视频，加了鼠标样式，文字动画

修改鼠标样式代码如下

```js
/*
<div class="section-2" style="width: 100%">
  <video src="xxx" muted autoplay loop style="width: 100%" ></video>
  <!-- @鼠标样式_start -->
  <div class="player-btn">
      <div>鼠标样式图片</div>
      <span class="text">观看完整视频</span>
  </div>
</div>
*/
let section2El = document.querySelector(".section-2");
let playBtnEl = document.querySelector(".player-btn");
section2El.addEventListener("click", (e) => {
  // alert("播放视频");
});
window.addEventListener(
  "mousemove",
  _.throttle((e) => {
    // 鼠标相对页面的位置
    let x = e.pageX;
    let y = e.pageY;
    // section-2 容器相对视口位置
    let parentX = section2El.offsetLeft;
    let parentY = section2El.offsetTop;
    let isYOut = y < parentY || y > parentY + section2El.clientHeight;
    let isXOut = x < parentX || x > parentX + section2El.clientWidth;
    if (isXOut || isYOut) {
      // console.log("移出去了");
      playBtnEl.style.opacity = "0";
      return;
    } else {
      playBtnEl.style.opacity = "1";
    }
    // 鼠标不在正中心，需要减去鼠标样式区域的宽高才能达到居中效果
    playBtnEl.style.left = `${x - parentX - playBtnEl.clientWidth / 2}px`;
    playBtnEl.style.top = `${y - parentY - playBtnEl.clientHeight / 2}px`;
  }, 50)
);
```

文字也有一个过渡动画，通过 clip-path 进行显示隐藏切换，再加上 transition 过渡

```css
/* 初始化时，默认隐藏文字 */
.section-2-text .title {
  transition: all 0.7s; /* 当 css 属性发生变化时，0.7s 内完成变更 */
  /* 裁剪路径，inset 显示这个区域的内容，right、left 50%，会隐藏元素 */
  clip-path: inset(0 50% 0 50%);
  /*滚动到当前区域时，增加 class*/
}
```

通过 gsap 判断滚动距离，当这个区域滚动到视口中间(center)时，触发 class 添加。有 transition 就形成了动画

```js
// 到视口中间时，父元素添加一个 fade-in 样式，显示该元素
.section-2.fade-in .title {
  clip-path: inset(0 0 0 0); /* 滚到到视口时，显示元素 */
}

// gsap 滚动处理
gsap.registerPlugin(ScrollTrigger);
gsap.to(".section-2-text", {
  opacity: 1,
  scrollTrigger: {
    trigger: ".section-2",
    start: "top center", // 当元素顶部部，滚动到达视口中间时, 开始动画
    // end 默认是 trigger 离开视口
    toggleClass: "fade-in",
    scrub: true, // 表示动画可以重复执行改成false表示只执行一次
    // markers: true, // 绘制开始位置和结束位置的线条
    // pin: false, // 动画执行期间，页面不进行滚动，动画执行结束后
  },
});
```

3、星空背景动画

![find_x3_section-3.gif](/images/daily/find_x3_section-3.gif)

```js
<canvas id="zn-starry-star" width="1440" height="969"></canvas>
```

代码为 canvas，通过 F12 查看 source，搜索 js 文件里面的 zn-starry-star 关键字，找到核心代码

![find_x3_section_star_source.png](/images/daily/find_x3_section_star_source.png)

查找前后代码，如下 <https://www.oppo.com/content/dam/oppo/product-asset-library/find-x3-series/fussi-mars/v1/main-v3.js>

关键字： vec4 星空动画 vec4 canvas 星空动画 vec4 canvas 星空动画

关键字： three.js 星空，搜索到一个比较接近的星空效果，地址：[three.js 制作星空](https://blog.csdn.net/ephemeral_x/article/details/116841238)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3Dstar</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
    <script src="./threejs/three.min.js"></script>
    <script src="./threejs/OrbitControls.js"></script>
    <!-- 
      建议保存到本地， 文件链接：
      https://cdn.bootcdn.net/ajax/libs/three.js/0.149.0/three.min.js
      http://nice.zuo11.com/3-find-x3-mars/threejs/OrbitControls.js 
     -->
  </head>
  <body>
    <script>
      /**
       * 创建场景对象Scene
       */
      var scene = new THREE.Scene();
      var intersectsArr = [];

      //星空背景
      var cloud = cloudFun();
      scene.add(cloud);

      function cloudFun() {
        var geom = new THREE.Geometry();
        var material = new THREE.ParticleBasicMaterial({
          size: 2,
          vertexColors: true,
        });
        var n = 1200;
        for (var i = 0; i < 3000; i++) {
          var particle = new THREE.Vector3(
            (Math.random() - 0.5) * n,
            (Math.random() - 0.5) * n,
            (Math.random() - 0.5) * n
          );
          geom.vertices.push(particle);
          let color_k = Math.random();
          // 蓝白色
          // geom.colors.push(new THREE.Color(color_k, color_k, color_k * 2.0));
          // 橙色为RGB为255,165,0,代码#FFA500
          geom.colors.push(new THREE.Color(color_k * 10, color_k * 3, color_k));
        }
        var cloud = new THREE.ParticleSystem(geom, material);
        return cloud;
      }

      /**
       * 透视投影相机设置
       */
      var width = window.innerWidth; //窗口宽度
      var height = window.innerHeight; //窗口高度
      /**透视投影相机对象*/
      var camera = new THREE.PerspectiveCamera(60, width / height, 1, 1000);
      camera.position.set(651, 613, 525); //设置相机位置
      camera.lookAt(scene.position); //设置相机方向(指向的场景对象)

      /**
       * 光源设置
       */
      //点光源
      var point = new THREE.PointLight(0xffffff);
      point.position.set(800, 200, 300);
      scene.add(point);
      // 点光源2  位置和point关于原点对称
      var point2 = new THREE.PointLight(0xffffff);
      point2.position.set(0, -500, 0); //点光源位置
      scene.add(point2); //点光源添加到场景中

      //环境光
      var ambient = new THREE.AmbientLight(0x000000);
      scene.add(ambient);

      /**
       * 创建渲染器对象
       */
      var renderer = new THREE.WebGLRenderer({
        antialias: true,
      });
      renderer.setSize(width, height); //设置渲染区域尺寸
      renderer.setClearColor(0x101010, 1); //设置背景颜色
      document.body.appendChild(renderer.domElement); //body元素中插入canvas对象

      let clock = new THREE.Clock();
      var FPS = 30;
      var refreshTime = 1 / FPS;
      var timeS = 0;
      function render() {
        var renderInterval = clock.getDelta();
        timeS = timeS + renderInterval;
        if (timeS > refreshTime) {
          //执行渲染操作
          renderer.render(scene, camera);
          timeS = 0;
        }
        //每次渲染位置变化，动态效果
        cloud.rotation.x += 0.0002;
        cloud.rotation.y += 0.0002;
        cloud.rotation.z += 0.0002;
        //周期性渲染
        requestAnimationFrame(render);
      }

      render();
      var controls = new THREE.OrbitControls(camera); //创建控件对象
    </script>
  </body>
</html>
```

[three.js 星空在线预览](http://nice.zuo11.com/3-find-x3-mars/three-js-star.html)

相关链接：

- [Three.js零基础入门教程(郭隆邦)](http://www.yanhuangxueyuan.com/Three.js/)
- [webgl 学习笔记（二）](https://juejin.cn/post/7013192849671847949#heading-16)

gsap 逻辑与 clip-path 逻辑

- 内容分为 5 个部分，每个部分都是重叠的，初始都是隐藏的，opacity为 0， clip-path 左边裁切 100%（不显示）
- 当滚动到对应的区域时，增加 active 属性，opacity 过渡到 1, clip-path 右裁切过渡到0 （不裁剪，完全显示）
- 第一个动画结束后，onLeave 钩子里，开启下一个场景 active 添加。onEnter 钩子里面切换当前进度百分比显示
- 整体的 pin 使用了父元素 pin，end 为滚动到 3000px 后，才结束固定。（屏幕适配可能会有问题，待优化）

```html
<style>
.section-3-info .part img,
.left-desc .text-title,
.left-desc .text-detail {
  clip-path: inset(0 0 0 100%); /* 左侧裁剪 100% => 左侧裁剪 0%， 从右到左*/
  opacity: 0;
}
.section-3-info .part img {
  transition: clip-path 0.8s, opacity 0.8s;
}
.left-desc .text-title {
  transition: clip-path 0.4s, opacity 0.4s;
}
.left-desc .text-detail {
  transition: clip-path 0.4s 0.2s, opacity 0.6s;
}
.part.active .text-title, 
.part.active .text-detail, 
.part.active img {
  opacity: 1;
  clip-path: inset(0 0 0 0);
}
</style>
<script>
const changeProgress = (val) => {
  document.querySelector("#progress").innerHTML = `${val}%`;
};
let tl = gsap.timeline();
tl.to(".part-1", {
  opacity: 1,
  scrollTrigger: {
    trigger: ".part-1",
    start: "top top",
    end: "+1000",
    toggleClass: "active",
    scrub: true, // 表示动画可以重复执行改成false表示只执行一次
    //   markers: true, // 绘制开始位置和结束位置的线条
    onEnter: function () {
      changeProgress(33);
    },
    onEnterBack: function () {
      changeProgress(33);
    },
    onLeave: function () {
      gsap.to(".part-2", {
        opacity: 1,
        scrollTrigger: {
          trigger: ".part-2",
          start: "top top",
          end: "+1000",
          toggleClass: "active",
          scrub: true, // 表示动画可以重复执行改成false表示只执行一次
          // markers: true, // 绘制开始位置和结束位置的线条
          onEnter: function () {
            changeProgress(66);
          },
          onEnterBack: function () {
            changeProgress(66);
          },
          onLeave: function () {
            gsap.to(".part-3", {
              opacity: 1,
              scrollTrigger: {
                trigger: ".part-3",
                start: "top top",
                end: "+1000",
                toggleClass: "active",
                scrub: true, // 表示动画可以重复执行改成false表示只执行一次
                //   markers: true, // 绘制开始位置和结束位置的线条
                onEnter: function () {
                  changeProgress(100);
                },
                onEnterBack: function () {
                  changeProgress(100);
                },
                onLeave: () => {
                  // gsap.set('.part-2', {autoAlpha: 0});
                },
              },
            });
          },
        },
      });
    },
  },
});

// 固定容器
gsap.to(".section-3", {
  opacity: 1,
  scrollTrigger: {
    trigger: ".section-3",
    start: "top top", // 当元素顶部部，滚动到达视口中间时, 开始动画
    // end 默认是 trigger 离开视口
    end: "+3000", // 当section-2底部，到达可视区域bottom 500px时，结束动画
    // scrub: true, // 表示动画可以重复执行改成false表示只执行一次
    // markers: true, // 绘制开始位置和结束位置的线条
    pin: true, // 动画执行期间，页面不进行滚动，动画执行结束后
    onEnterBack() {
      document.querySelector('.abs.s-4-2').classList.remove('active')
      document.querySelector('.comp-inner').classList.remove('active')
    }
  },
});
</script>
```

小黄点定位 css animation

![find-x3-mars-orange-dot-animation.gif](/images/daily/find-x3-mars-orange-dot-animation.gif)

```html
<style>
@keyframes circleScale {
  from {
    transform: scale(2);
  }
  to {
    transform: scale(0.5);
  }
}
@keyframes circleScaleSlow {
  from {
    transform: scale(1);
  }
  to {
    transform: scale(0.5);
  }
}
.circle-wrapper .fast-flow,
.circle-wrapper .slow-flow {
  width: 100%;
  height: 100%;
  position: absolute;
  opacity: 1;
  border: 1px solid #ff995e;
  background: transparent;
  border-radius: 50%;
}
.circle-wrapper .fast-flow {
  animation: circleScale 1.5s ease infinite;
}
.circle-wrapper .slow-flow {
  animation: circleScaleSlow 1.5s ease infinite;
}
/* 中心小黄点 */
.circle-wrapper .circle {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #ff995e;
    margin-top: 50%;
    margin-left: 50%;
    transform: translate(calc(-50% + 1px), calc(-50% + 1px));
}
</style

<body>
  <!-- 所在位置 点 动画-->
  <div class="circle-wrapper abs circle1">
    <div class="fast-flow"></div>
    <div class="slow-flow"></div>
    <div class="circle"></div>
  </div>
</body>
```

其他场景代码参见：  <https://github.com/zuoxiaobai/nice-func/tree/main/src/3-find-x3-mars>

## 2023-02-02

### 关于 vue3 composition 与 utils 功能的区分界定

一般 vue3 composition 里面也可以写纯 js 逻辑，但建议仅当包含 vue 相关代码时，才使用 composition use-xx 来定义。

对于纯 js 逻辑或者 dom 操作，使用 utils 就行。

比如下面这种包含 vue 方法的，可以使用 composition 格式定义

```js
import { ref } from "vue";
//
export const useXxx = () => {
  const foo = ref("test");
  return { foo };
};
```

针对下面的纯 js 逻辑，建议放到 utils 分类中

```js
const xxx = () => {
  document.querySelector("xxx").xx; // 一些 dom 操作
  // 其他 js 逻辑等
};
```

### 关于算法系统化学系、刷题

hello 算法教程

- 第一步：算法快速入门 [Hello 算法 - 多语言示例-插图/动图设计感好 - 适合入门](https://github.com/krahets/hello-algo)
- 第二步：按计划刷题 [剑指 Offer》刷题计划](https://github.com/krahets/LeetCode-Book)

宫水三叶

- [宫水三叶的刷题日记](https://github.com/SharingSource/LogicStack-LeetCode)
- wiki 里面有分类、难易度标记 [](https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E5%9B%BE%E8%AE%BA-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F)

其他

- [LeetCodeAnimation - 吴师兄学算法](https://github.com/MisterBooo/LeetCodeAnimation)
- [azl397985856/leetcode 50.4k star](https://github.com/azl397985856/leetcode)

### 怎么通过前端 js 代码计算页面的 fps

在看 [揭秘 Vue.js 九个性能优化技巧](https://juejin.cn/post/6922641008106668045) 这边文章时，发现 [演示项目](https://github.com/Akryum/vue-9-perf-secrets/) 右上角有一个实时显示页面 fps 的功能，如下图

![fps.gif](/images/daily/fps.gif)

这个功能时怎么实现的呢？查看源码后发现，是引入了一个 `fps-indicator` js 库，使用方法如下

```js
// src/main.js
import fps from "fps-indicator";

fps({
  position: "top-right",
  style: `
    font-size: 24px;
  `,
});
```

核心实现代码，通过触发 requestAnimationFrame 函数来计算 fps，基本上执行一次该函数就是一帧

- [raf](https://www.npmjs.com/package/raf)，可以直接理解为 requestAnimationFrame，封了一层，做了一些兼容性处理

```js
//enable update routine
var that = this;
raf(function measure() {
  count++;
  var t = now();

  if (t - lastTime > period) {
    lastTime = t;
    values.push(count / (max * period * 0.001));
    values = values.slice(-w);
    count = 0;

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = getComputedStyle(that.canvas).color;
    for (var i = w; i--; ) {
      var value = values[i];
      if (value == null) break;
      ctx.fillRect(i, h - h * value, 1, h * value);
    }

    that.valueEl.innerHTML = (values[values.length - 1] * max).toFixed(1);
  }

  raf(measure);
});
```

完整代码

```js
/**
 * @module fps-indicator
 */
var raf = require("raf");
var now = require("right-now");
var css = require("to-css");
module.exports = fps;

function fps(opts) {
  if (!(this instanceof fps)) return new fps(opts);

  if (typeof opts === "string") {
    if (positions[opts]) opts = { position: opts };
    else opts = { container: opts };
  }
  opts = opts || {};

  if (opts.container) {
    if (typeof opts.container === "string") {
      this.container = document.querySelector(opts.container);
    } else {
      this.container = opts.container;
    }
  } else {
    this.container = document.body || document.documentElement;
  }

  //init fps
  this.element = document.createElement("div");
  this.element.className = "fps";
  this.element.innerHTML = [
    '<div class="fps-bg"></div>',
    '<canvas class="fps-canvas"></canvas>',
    '<span class="fps-text">fps <span class="fps-value">60.0</span></span>',
  ].join("");
  this.container.appendChild(this.element);

  this.canvas = this.element.querySelector(".fps-canvas");
  this.textEl = this.element.querySelector(".fps-text");
  this.valueEl = this.element.querySelector(".fps-value");
  this.bgEl = this.element.querySelector(".fps-bg");

  var style = opts.css || opts.style || "";
  if (typeof style === "object") style = css(style);

  var posCss = "";
  posCss = positions[opts.position] || positions["top-left"];

  this.element.style.cssText = [
    "line-height: 1;",
    "position: fixed;",
    "font-family: Roboto, sans-serif;",
    "z-index: 1;",
    "font-weight: 300;",
    "font-size: small;",
    "padding: 1rem;",
    posCss,
    opts.color ? "color:" + opts.color : "",
    style,
  ].join("");

  this.canvas.style.cssText = [
    "position: relative;",
    "width: 2em;",
    "height: 1em;",
    "display: block;",
    "float: left;",
    "margin-right: .333em;",
  ].join("");

  this.bgEl.style.cssText = [
    "position: absolute;",
    "height: 1em;",
    "width: 2em;",
    "background: currentcolor;",
    "opacity: .1;",
  ].join("");

  this.canvas.width = parseInt(getComputedStyle(this.canvas).width) || 1;
  this.canvas.height = parseInt(getComputedStyle(this.canvas).height) || 1;

  this.context = this.canvas.getContext("2d");

  var ctx = this.context;
  var w = this.canvas.width;
  var h = this.canvas.height;
  var count = 0;
  var lastTime = 0;
  var values = opts.values || Array(this.canvas.width);
  var period = opts.period || 1000;
  var max = opts.max || 100;

  //enable update routine
  var that = this;
  raf(function measure() {
    count++;
    var t = now();

    if (t - lastTime > period) {
      lastTime = t;
      values.push(count / (max * period * 0.001));
      values = values.slice(-w);
      count = 0;

      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = getComputedStyle(that.canvas).color;
      for (var i = w; i--; ) {
        var value = values[i];
        if (value == null) break;
        ctx.fillRect(i, h - h * value, 1, h * value);
      }

      that.valueEl.innerHTML = (values[values.length - 1] * max).toFixed(1);
    }

    raf(measure);
  });
}

var positions = {
  "top-left": "left: 0; top: 0;",
  "top-right": "right: 0; top: 0;",
  "bottom-right": "right: 0; bottom: 0;",
  "bottom-left": "left: 0; bottom: 0;",
};
```

### git switch 和 git checkout 都可以切换分支，有什么区别？

一般 git checkout 和 git switch 都可以切换分支，他们有什么区别？

Git 2.23 引入了 git switch 命令

- git-switch - Switch branches [switch - git](https://git-scm.com/docs/git-switch)
- git-checkout - Switch branches or restore working tree files [checkout - git](https://git-scm.com/docs/git-checkout)

The first rule of Doug McIlroy’s UNIX Philosophy says:

> Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new “features”.

"新增一个功能，最好创建新的功能模块，而不是通过在旧功能上新增一个补丁特性来实现"

**git checkout does too many things**，has not followed this philosophy very closely.

大致意思是，git checkout 功能太复杂了，有 6 种用法。破坏的 git 用户体验

git switch 更加语义化，功能更简洁一点，对用户更友好。

参考：

- [What's the Difference Between Git Switch and Checkout?](https://linuxhandbook.com/git-switch-checkout/)
- [Two Commits That Wrecked the User Experience of Git](https://redfin.engineering/two-commits-that-wrecked-the-user-experience-of-git-f0075b77eab1)

### eslint+prettier 自动修复 template 时，元素换行异常问题解决

下面这行代码在保存后自动 fix 时， el-button 的结束标签换行异常

![prettier自动fix后元素结束标签换行异常问题.png](/images/daily/prettier自动fix后元素结束标签换行异常问题.png)

```html
<el-button type="primary" text @click="deleteShortLink(scope.$index)"
  >删除</el-button
>
<!--
Replace `>删除</el-button` with `⏎············>删除</el-button⏎··········`eslintprettier/prettier
-->
```

这种情况需要修改 prettier 配置

```js
// .prettierrc.json 或 .prettierrc.js
{
    "htmlWhitespaceSensitivity": "ignore"
}
```

修改后，再保存就正常了，**注意：一般情况下，这里修改 prettier 配置后，需要关闭 vscode 项目，再重新打开，配置才会生效**

![prettier配置修改后效果.png](/images/daily/prettier配置修改后效果.png)
